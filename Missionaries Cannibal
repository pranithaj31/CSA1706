from collections import deque

def valid(state):
    m_left, c_left, boat = state
    m_right = 3 - m_left
    c_right = 3 - c_left

    # Check for invalid numbers
    if min(m_left, c_left, m_right, c_right) < 0 or max(m_left, c_left, m_right, c_right) > 3:
        return False

    # Missionaries can't be outnumbered on any side (unless missionaries are zero)
    if m_left > 0 and c_left > m_left:
        return False
    if m_right > 0 and c_right > m_right:
        return False

    return True

def get_moves(state):
    m_left, c_left, boat = state
    moves = [(1,0),(2,0),(0,1),(0,2),(1,1)]
    next_states = []

    if boat == 1:  # boat on left side
        for m,c in moves:
            new_state = (m_left - m, c_left - c, 0)
            if valid(new_state):
                next_states.append(new_state)
    else:  # boat on right side
        for m,c in moves:
            new_state = (m_left + m, c_left + c, 1)
            if valid(new_state):
                next_states.append(new_state)

    return next_states

def solve():
    start = (3, 3, 1)
    goal = (0, 0, 0)
    queue = deque([(start, [start])])
    visited = set([start])

    while queue:
        state, path = queue.popleft()
        if state == goal:
            return path
        for next_state in get_moves(state):
            if next_state not in visited:
                visited.add(next_state)
                queue.append((next_state, path + [next_state]))
    return None

# Run solver and print result
solution = solve()
if solution:
    for s in solution:
        m, c, b = s
        side = "left" if b == 1 else "right"
        print(f"Missionaries: {m}, Cannibals: {c}, Boat on {side}")
else:
    print("No solution found.")
